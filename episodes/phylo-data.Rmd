---
title: "Summarizing phylogenetic data"
teaching: 10
exercises: 2
editor_options:
  markdown:
    wrap: 72
---

::: questions

- What are the common phylogeny data formats?
- How do you import and manipulate phylogeny data in R?
- How do you visualize phylogenies in R?
- How to summarize and interpret phylogenies using Hill numbers?

:::::::::::::


::: objectives

After following this episode, participants will be able to:

1. Identify key features of different phylogenetic data formats
2. Import, clean and manipulate phylogenetic data in the R environment
3. Visualize phylogenies
4. Calculate and interpret phylogenetic Hill numbers

::::::::::::::

### Introduction

In this episode, we will explore how to extract information from phylogenetic trees in order to complement our hypotheses and inferences about processes shaping biodiversity patterns. Phylogenetic trees have information about how the species in a taxonomic group are related to each other and how much relative evolutionary change has accumulated among them. Since local communities differ in their phylogenetic composition, this information can give insights on why communities are how they are.

The relative phylogenetic distance among species in a community as well as the distribution of the amount of evolutionary history (represented by the length of the branches in a phylogeny) are a result of different factors such as the age since the initial formation of the community and the rate of macroevolutionary processes such as speciation and extinction. For instance, young communities that are dominated by closely related species and show very short branch lengths may suggest a short history with few colonization events and high rates of local speciation; alternatively, if the same young communities harbor distantly related species with longer branch lengths, it may suggest that most of the local diversity was generated by speciation elsewhere, along with many colonization by species from different points in the phylogeny. Coupled with information on ecological traits and rates of macroevolutionary processes, these patterns also allow to test for hypotheses regarding, for instance, ecological filtering or niche conservatism.

> Maybe bring in the paragraph above explicit connections to our young vs older Hawaian islands examples.

Summarizing this phylogenetic information (i.e., phylogenetic distance and distribution of branch lenghts) is therefore crucial for inference. As we have seen in previous episodes, the use of [Hill numbers]() is an informative approach to summarize biodiversity. In this episode, we will then go over 1) how to import and manipulate phylogenetic data in R; 2) how to calculate and interpret Hill numbers for different communities.

### Importing phylogenetic data

Several file formats exist to store phylogenetic information. The most common formats are the [Newick]() and [Nexus]() formats. Both these formats are plain text files storing different levels of information about the taxa relationship and evolutionary history. `Newick` files are the standard for representing trees in a computer-readable form, as they can be extremely simple and therefore do not take up much memory. `Nexus` file, on the other hand, are composed by different blocks regarding different types of information and can be used to store DNA alignments, phylogenetic trees, pre-defined groupings of taxa, or everything at once. Since they are a step ahead in complexity, we will stick with `Newick` files for now.

`Newick` files store the information about the clades in a tree by representing each clade within two parentheses, with tips separated by `,`. We also add the symbol `;` at the end to represent the end of the information for that phylogenetic tree.

The basic structure of a tree in a `Newick` format is therefore as follows:

((A,B),C);

> Probably insert here a simple figure, instead of the written text.

The notation above indicates that: 1) we have three taxa in our tree, named `A`, `B` and `C`; 2) `A` and `B` form one clade (A,B); 3) the (A,B) clade is sister to the `C` clade (we represent that by adding another set of parentheses and a `,` separating (A,B) from C).

In addition, `Newick` files can also store information on the branch leading to it tip and node. We do that by adding `:` after each tip/node.

((A:0.5,B:0.5):0.5,C:1.5);

The notation above indicates that: 1) the branches containing A and B have each a length = 0.5; 2) the branch that leads to the node connecting A and B also has length = 0.5; 3) the branch leading to C has length = 1.5.

The notation above is what we import into R to start working with and manipulating our phylogenetic tree. For that goal, we will use the [ape](package):

```{r}
library(ape)
```

To import our tree, we will be using the function `read.tree()` from the `ape` package. In the case of simple trees as the one above, we could directly create them within R by giving that notation as a `character` value this function, using the `text` argument, as shown below:

```{r}
example_tree <- read.tree(text = '((A:0.5,B:0.5):0.5,C:1.5);')
```

We can visually inspect our tree using the `plot()` function:

```{r}
plot(example_tree)
```

The `read.tree()` creates an object of class `phylo`. We can further investigate this object by calling it in our console:

```{r}
example_tree
```

The printed information shows us that we have a phylogenetic tree with 3 tips and 2 internal nodes, where the tip labels are "A, B, C". We also are informed that this tree is [rooted]() and has branch lengths.

We can use `$` to access the components of this object. Specifically, it will be important for us to know where the tip labels and the branch lengths are stored. Easy enough, this information is stored under `tip.labels` and `edge.length` components of this object.

```{r}
example_tree$tip.label
example_tree$edge.length
```

Now that we learned how to import and visualize trees in R, let's bring the phylogeny of our simulated dataset

::: challenge

`gnr_resolve()`

Save back to `tip.labels` in the same order

::: solution

::::::::::::

::::::::::::


We will use that to check our taxonomic information

### Modifying the phylogenetic tree

Same code from abundance and traits episode.

::: challenge

`gnr_resolve()`

Save back to `tip.labels` in the same order

::: solution

::::::::::::

::::::::::::


`keep.tip()` based on on sites-by-spp matrix, or spp column in abundance table.

Plot again to show new tree. Show some more options to customize plot.


=======
Should I show here how to retrieve branch lengths and check the evenness of the distribution, as a prelude to hill numbers?

`ape` to do modifications
`keep.tip`
`drop.tip`
`ggtree` to visualize changes

### Calculating hill numbers

- Recap the idea of hill numbers. How they apply to phylogenies = here we are calculating branch lengths and the distribution of those lengths across the community.
- Values of hill numbers can give an idea of the relative length of the branches across the community and help answer the questions abvoe.
- Maybe show here a SAD-like distribution of branch lengths to give an intuition of the evenness?

1. Briefly recap the meaning of hill numbers for phylogenetic trees, which was explained in intro

Should I show here how to manually retrieve branch lengths and check the evenness of the distribution, as a prelude to hill numbers? How much of that was done in previous episodes?

Question: steps 2 to 3 or jump to step 5?

2. Start with toy trees tree with 6 clades. Show `hill_phylo` on that tree. Highlight `hill_phylo` needs a spp-by-site matrix, but here we'll just make a matrix where all species of the tree are present.

=======
3. Andy's comments:
- Play aroud with toy trees: ladder phylogenies and perfectly balanced trees
Totally Balanced - short and long
Totally unbalanced
6 clades

```{r}

tre1 <- read.tree(text='(a:3,(b:2,(c:1,d:1):1):1);')
tre2 <- read.tree(text='((a:1,b:1):1,(c:1,d:1):1);')

site_m <- data.frame(rbind(rep(1,4)))
colnames(site_m) <- c('a','b','c','d')

library(hillR)
hill_phylo(site_m,tre1)
hill_phylo(site_m,tre2)

```

4. **Do this??** - Show two additional toy trees trees that has same topology as first one, but differ in branch lengths: 1) younger diversification (shorter branch lengths) and 2) older diversification (longer branch lengths). Ask them to calculate hill number for them and compare. What can we see? Here, we should be able to see branch lengths being different. How that reflect in terms of the community? Younger community vs older community?

5. Jump to `hill_phylo` function - show how the function automatically calculates phylo hill numbers for each community based on a global tree. Do the calculating for all islands in our simulated dataset using the species-by-site matrix created in previous episodes.


Personal code for me to better understand phylogenetic hill numbers:

```{r}
# Creating a site matrix with one site and four taxa all present in the one site
site_m <- data.frame(rbind(rep(1,4)))
colnames(site_m) <- paste0('t',seq(1:4))

# Six random trees
trees <- rmtopology(6,4,rooted = TRUE)
trees <- lapply(trees,FUN = force.ultrametric)
hill_data <- c()
for (i in 1:length(trees)) {
  hill0 <- hill_phylo(site_m, trees[[i]], q = 0)
  hill1 <- hill_phylo(site_m, trees[[i]], q = 1)
  hill2 <- hill_phylo(site_m, trees[[i]], q = 2)
  hill_data <- rbind(hill_data,c(hill0,hill1,hill2,trees[[i]]$edge.length))
}
colnames(hill_data) <- c('hill_0','hill_1','hill_2',paste0('edge_',seq(1:6)))

# Plotting SAD of branch lenghts for each tree
plot(data.frame(seq(1:6),sort(hill_data[1,4:9],decreasing = TRUE)))
plot(data.frame(seq(1:6),sort(hill_data[2,4:9],decreasing = TRUE)))
plot(data.frame(seq(1:6),sort(hill_data[3,4:9],decreasing = TRUE)))
plot(data.frame(seq(1:6),sort(hill_data[4,4:9],decreasing = TRUE)))
plot(data.frame(seq(1:6),sort(hill_data[5,4:9],decreasing = TRUE)))
plot(data.frame(seq(1:6),sort(hill_data[6,4:9],decreasing = TRUE)))
```

Personal notes:
* Order 0 is just the sum of branch lengths… From order 1 and above, you weight by the abundance of that branch length in the tree… Like, how many branches have high length vs how many branchs have low length? In order one, if you have one branch that is super long and all others are super short, your hill number drops: your PD is driven by only one branch… If branch length is evenly distributed through the phylogeny (i.e., several branches with similar lenghts), then your PD increases… That is a Shannon entropy index basically…
* As you increase the order of the hill number, you are giving more weight to highly abundant branch lenghts… Order 0 is just the sum of lenghts, 1 is weight by evenness, 2 is weighted by evenness giving more weight to values of branch lengths that are more abundant, 3 is the same but focusing even more on the most abundance values (i.e., as you increase the order, you decrease your focus on rare values)…  So, like, if you have a phylogeny dminated by few branches that are very long, your hill number drops really fast as you move up in the orders… Because your hill number becomes dictated by only a few branches very fast… Whereas if you have a more even distribution of branch lenghts (several branch with similar values of length), the hill number doesn’t change as much as you move higher in the order, because even high orders still focus on most of the branches (as they are the most abundant, since they are equally abundant)
* If all branches had the exact same branch length, then hill numbers wouldn’t change as you go up in the orders (i.e, evenness is perfect)
