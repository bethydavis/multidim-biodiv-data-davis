---
title: "Summarizing phylogenetic data"
teaching: 10
exercises: 2
output: pdf_document
editor_options:
  markdown:
    wrap: 72
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,  results = FALSE, eval = TRUE)

```

::: questions

- What information is contained in phylogenies?
- How to summarize and interpret phylogenies using Hill numbers?
- What are the common phylogeny data formats?
- How do you import and manipulate phylogeny data in R?
- How do you visualize phylogenies in R? 
- How do you calculate Hill numbers with phylogenetic data?

:::::::::::::


::: objectives

After following this episode, participants will be able to:

1. Identify key features of different phylogenetic data formats
2. Import, clean and manipulate phylogenetic data in the R environment
3. Visualize phylogenies
4. Calculate and interpret phylogenetic Hill numbers

::::::::::::::

## Introduction to phylogenetic data

In this episode, we will explore how to extract information from phylogenetic trees in order to complement our hypotheses and inferences about processes shaping biodiversity patterns. Phylogenetic trees have information about how the species in a taxonomic group are related to each other and how much relative evolutionary change has accumulated among them. Since local communities differ in their phylogenetic composition, this information can give insights on why communities are how they are.

[HERE INCLUDE VISUALS OF PHYLOGENIES]

The relative phylogenetic distance among species in a community as well as the distribution of the amount of evolutionary history (represented by the length of the branches in a phylogeny) are a result of different factors such as the age since the initial formation of the community and the rate of macroevolutionary processes such as speciation and extinction. For instance, young communities that are dominated by closely related species and show very short branch lengths may suggest a short history with few colonization events and high rates of local speciation; alternatively, if the same young communities harbor distantly related species with longer branch lengths, it may suggest that most of the local diversity was generated by speciation elsewhere followed by colonization events involving distantly related species. Coupled with information on ecological traits and rates of macroevolutionary processes, these patterns also allow to test for hypotheses regarding, for instance, ecological filtering or niche conservatism.

Summarizing this phylogenetic information (i.e., phylogenetic distance and distribution of branch lengths) is therefore important for inference. As we have seen in previous episodes, the use of [Hill numbers](https://onlinelibrary.wiley.com/doi/10.1111/eva.12593) is an informative approach to summarize biodiversity. 

[MORE HERE ON MEANING OF PHYLOGENETIC HILL, RELATING TO PHYLO CHARACTERISTICS]

## Working with phylogenetic data in R

### Importing phylogenetic data

Several file formats exist to store phylogenetic information. The most common formats are the [Newick and Nexus formats](https://evomics.org/resources/tree-formats/). Both these formats are plain text files storing different levels of information about the taxa relationship and evolutionary history. `Newick` files are the standard for representing trees in a computer-readable form, as they can be extremely simple and therefore do not take up much memory. `Nexus` file, on the other hand, are composed by different blocks regarding different types of information and can be used to store DNA alignments, phylogenetic trees, pre-defined groupings of taxa, or everything at once. Since they are a step ahead in complexity, we will stick with `Newick` files for now.

`Newick` files store the information about the clades in a tree by representing each clade within a set of parentheses. Sister clades are separated by `,`. The notation also requires us to add the symbol `;` to represent the end of the information for that phylogenetic tree.

The basic structure of a tree in a `Newick` format is therefore as follows:

((A,B),C);

The notation above indicates that:
1. we have three taxa in our tree, named `A`, `B` and `C`;
2. `A` and `B` form one clade (A,B);
3. the (A,B) clade is sister to the `C` clade (we represent that by adding another set of parentheses and a `,` separating (A,B) from C).

In addition, `Newick` files can also store information on the branch leading to it tip and node. We do that by adding `:` after each tip/node.

((A:0.5,B:0.5):0.5,C:1);

The notation above indicates that:
1. the branches containing A and B have each a length = 0.5;
2. the branch that leads to the node connecting A and B also has length = 0.5;
3. the branch leading to C has length = 1.

The notation above is what we import into R to start working with and manipulating our phylogenetic tree. For that goal, we will use the [ape](https://academic.oup.com/bioinformatics/article/20/2/289/204981) package:

```{r loading-ape}
library(ape)
```

To import our tree, we will be using the function `read.tree()` from the `ape` package. In the case of simple trees as the one above, we could directly create them within R by giving that notation as a `character` value to this function, using the `text` argument, as shown below:

```{r read-example}
example_tree <- read.tree(text = '((A:0.5,B:0.5):0.5,C:1);')
```

Now, we can visually inspect our tree using the `plot()` function:

```{r plot-example}
plot(example_tree)
```

Can you visualize the text notation in that image? We can see the same information: A is closer related to B than C, and the branches leading to A and B have half the length of the branch leading to C.

The `read.tree()` function creates an object of class `phylo`. We can further investigate this object by calling it in our console:

```{r calling-example}
example_tree
```

The printed information shows us that we have a phylogenetic tree with 3 tips and 2 internal nodes, where the tip labels are "A, B, C". We also are informed that this tree is rooted and has branch lengths.

One way to access the components of this object and better explore it is to use `$` after the object name. Here, it will be important for us to know a little bit more about where the information about tip labels and branch lengths are stored in that `phylo` object. Easy enough, we can access that by calling `tip.labels` and `edge.length` after `$`.

```{r calling-tips-edge}
example_tree$tip.label

example_tree$edge.length
```

## Cleaning and filtering phylogenetic data

Now that we learned how to import and visualize trees in R, let's bring the phylogeny for the communities we are working with in this workshop. Our data so far consists of [abundances](abundance-data.Rmd) and [traits](traits-data.Rmd) of several taxa of arthropods collected across three islands in the Hawaiian archipelago. Let's work though importing phylogenetic information for these species.

Two common approaches to retrieving a phylogeny for a focal group are 1) relying on a published phylogeny for the group, or 2) surveying public phylogenetic databases based on your taxa list. A common option for the latter is the [Open Tree of Life Taxonomy](https://tree.opentreeoflife.org/about/taxonomy-version/ott3.2), a public database that synthesizes taxonomic information from different sources. You can even interact with this database using the R package `rotl`. A few tutorials to do so exist online, like [this one](https://mctavishlab.github.io/R_OpenTree_tutorials/). Using a public database is a good approach when working with taxonomic groups that are not heavily investigated regarding their phylogenetic relationships (the well-known [Darwinian shortfall](https://doi.org/10.1146/annurev-ecolsys-112414-054400)). In such cases, databases like OTL will give you a summary phylogeny already filtered for the taxa you have in hand and cross-checked for synonyms and misspellings.

For this workshop, since we are using simulated data, we will work with the first option: a "published" arthropod phylogeny. Let's load this phylogeny into R using the function `read.tree` we learned earlier.

```{r reading-arthro-phylo}
arthro_tree <- read.tree('link_to_phylogeny')

class(arthro_tree)
```

This new `phylo` object is way larger than the previous one, being a "real" phylogeny and all. You can inspect it again by directly calling the object `arthro_tree`. To plot it, we will use the `type` argument to modify how our tree will be displayed. Here, we used the option `'fan'`, to display a circular phylogeny (slightly better to show such a large phylogeny in the screen). We also set the `show.tip.label` argument to `False`.

```{r plotting-phylogeny}
plot(arthro_tree, type = 'fan', show.tip.label = F)
```

How do we combine all this information with the community datasets we have so far for our three islands? First, we will have to perform some name checking and filtering.

### Checking for missing tips

**Do we still want to keep this issue? Or simply skip ahead to pruning the phylogeny for each community?**

Since this is a "published" arthropod phylogeny, we will likely not have any misspelling in the tip names of the object. However, one important issue that may arise is that, depending on the resolution of the phylogeny, it may be the case that some taxa in our community dataset may not be explicitly represented in the phylogeny. For instance, the tips in our phylogeny might be represented by one species for each genus, or one genus for each family. This is usually the case when the goal of the original publication was to elucidate the phylogenetic relationship for such higher taxonomic levels, with less focus on the more recent evolutionary history. In these cases, some taxa in our [abundances](abundance-data.Rmd) dataset may not be found in the phylogeny, which will yield errors when we try to summarize phylogenetic diversity. Therefore, we will want to assign those "missing taxa" to one of the tips present in the tree, based on their known genus and/or family assignments.

Let's first find out what are those "missing taxa". For this, we'll refer back to our original species list, from the `abundances` object:

```{r}
all_names <- abundances$final_name
```

To cross-check this list against the list of names in our phylogeny, we can use the Boolean operator `%in%` coupled with `!`. This will allow us to check for names in `all_names` that are not included in the `arthro_tree$tip.label`. In summary, the expression `A %in% B` would return the position of the elements in vector A that are present in vector B. The `!` (NOT) operator returns the opposite of that expression, in a way that `!(A %in% B)` will return the position of elements in vector A that are *NOT* present in vector B (precisely what we need right now).

```{r}
not_found <- !(all_names %in% (arthro_tree$tip.label))
```

The object `not_found` is now a vector of the positions (or *indexes*) of the elements in `all_names` that are not found in `arthro_tree$tip.label`. Let's then check these names by using these indexes to subset `all_names`:

```{r}
all_names[not_found]
```

**EDIT THIS NEXT PARAGRAPH WHEN PHYLOGENY IS AVAILABLE**

Here, we can decide how we are going to assign these species to tips in our tree. For instance, we see that we do not have _XXX_ in our tree, but we have _XXX_, which belongs to the same genus. Similarly...

We can then give new names to these species, based on what tips in our tree we want them to match to. To do so, we will first duplicate our `all_names` vector into the `new_names` vector. This way, we can make our changes in `new_names` while keeping the original names intact, just in case we need to refer back to them in the future.

```{r}
new_names <- all_names
```

Now we use the indexes saved in `not_found` to replace the names in the positions with the ones we want:

```{r}
new_names[not_found] <- c('ADD_LIST_HERE')
```

Now that we have a vector where all names match to a position in our phylogeny, we need to bring these corrected names back to our abundance data. Here, we will again first copy our `abundances` object into another object, in order to keep the original data intact. Then, we will change the column `final_name` based on the vector `new_names`.

```{r}
abundances_phylo <- abundances
abundances_phylo$final_name <- new_names
```

### Pruning for local communities

**RM comment on this section: the abundances episode makes one site-by-species matrix containing all three islands. It would be nice to keep the same idea and do the same here: one new site-by-species matrix that now contains the taxa names corrected to fully match the phylogeny. However, this would mean it's unnecessary to prune the phylogeny for each island. Or we could keep the pruning (this way we can introduce the `keep.tip` function), and make one site-by-species matrix for each island (which would be different from the abundance episode). The latter option is how it is currently presented here.**

**MODIFY THIS**
**Add pruning to reduce phylogeny size, but not to prune for each community. This way we can still introduce `keep.tip` and be aligned with abundances episode creating just one site-by-species matrix**

Now that we have a modified abundance dataset where all taxa names are present in our phylogeny, we can work on the two bits of information we need from each community to summarize phylogenetic diversity (PD) using Hill numbers: a local phylogeny and a local site-by-species matrix.

We can filter our phylogeny for the taxa present in each community using the function `keep.tip` from the `ape` package. For this function, we provide the entire phylogeny plus the names of the tips we want to keep. We can retrieve those names from the new abundances dataset we create. We first need to retrieve only the names of taxa present in each island, and then provide those names to the function.

```{r}

HawaiiIsland_taxa <- abundances_phylo$final_name[abundances_phylo$island == 'HawaiiIsland']
HawaiiIsland_tree <- keep.tip(arthro_tree, HawaiiIsland_taxa)

Kauai_taxa <- abundances_phylo$final_name[abundances_phylo$island == 'Kauai']
Kauai_tree <- keep.tip(arthro_tree, Kauai_taxa)

Maui_taxa <- abundances_phylo$final_name[abundances_phylo$island == 'Maui']
Maui_tree <- keep.tip(arthro_tree, Maui_taxa)

```

Now, let's move on to create a site-by-species matrix for each island. We have done such a matrix in the [abundances](abundance-data.Rmd) episode before, so let's cover this in a challenge.

::: challenge

Make a site-by-species matrix for each community.
Hint: you will first want to filter the abundance data per community, and then transpose that data into the site-by-species matrix as done previouslyin the [abundances](abundance-data.Rmd) episode.

::: solution

First we split the new abundances data per island, using the `split` function`

```{r separate islands using split, eval =F}

island_abundances_phylo <- split(abundances_phylo, f = abundances_phylo$island)

```

Then we use `pivot_wider` from the package `tidyr` to create a site-by-species matrix for each island.

```{r}

HawaiiIsland_wide <- pivot_wider(island_abundances_phylo$HawaiiIsland,
                          names_from = final_name,
                          values_from = abundance, 
                          values_fill = 0)

Kauai_wide <- pivot_wider(island_abundances_phylo$Kauai,
                          names_from = final_name,
                          values_from = abundance, 
                          values_fill = 0)

Maui_wide <- pivot_wider(island_abundances_phylo$Maui,
                          names_from = final_name,
                          values_from = abundance, 
                          values_fill = 0)
```

**Alternative creating just one site-by-species matrix with islands as sites**

```{r}
abundance_wide <- pivot_wider(abundances_phylo,
                          id_cols = site,
                          names_from = final_name,
                          values_from = abundance, 
                          values_fill = 0)
```

::::::::::::

::::::::::::

## Summarizing with hill numbers

> Add the basic idea that hill number summarize amount of evolutionary change, with a simple example. Non-ultrametric trees with different branch lenghts?

After solving these issues, we now have 1) a phylogenetic tree with tip labels taxonomically cleaned; 2) a site-by-species matrix where all species are represented in our tree. These two objects are the two bits of information that we need to summarize the phylogenetic diversity and the distribution of branch lengths across our focal communities.

In this section, we will extract some summary statistics about the pattern of phylogenetic diversity in our communities. As we discussed above, the relative phylogenetic distance among species and the distribution of this distance can give insights into processes of community assembly. Here, we will make use of [Hill numbers](https://onlinelibrary.wiley.com/doi/10.1111/eva.12593) to extract summaries of phylogenetic distances. To understand what they mean, let's first explore their properties in a simple example.

Let's assume we have a community with eight taxa: A through H. We will create two possibilities of phylogenetic relationship among them.

Tree 1 will represent a totally unbalanced pattern...

```{r, eval=FALSE}
tree1 <- read.tree(text='(A:7,(B:6,(C:5,(D:4,(E:3,(F:2,(G:1,H:1):1):1):1):1):1):1);')
plot(tree1)
```

whereas tree 2 will represent a totally balanced pattern.

```{r, eval=FALSE}
tree2 <- read.tree(text='(((A:1,B:1):1,(C:1,D:1):1):1,((E:1,F:1):1,(G:1,H:1):1):1);')
plot(tree2)
```

Notice that both trees are ultrametric: all tips align at the end, representing extant taxa, which means branch lengths here represent the amount of time that has passed between each node. The difference between the first and the second tree resides in the fate of each new lineage at a node. In the first tree, at each diversification event, one of the lineages always persists till the present with no change while the other undergoes another round of diversification. In the second tree, both lineages from each node undergo a new split. The consequence is that in tree 2, all extant species result from recent diversification (i.e., they have a short evolutionary history before coalescing into their ancestor), whereas in tree 1 we have a mix of old and recent lineages.

To visualize how these different patterns reflect in the diversity metric, we will calculate the phylogenetic Hill number using the function `hill_phylo` from the `hillR` package. This function takes in a global phylogeny as well as a site-by-species matrix, and returns phylo Hill numbers for each site based on which species are present there. For our fictional example, we will create a matrix with only one site where all eight species in the tree are present. We do that by creating a vector of the value `1` repeated 8 times, transforming that to a dataframe, and then naming the columns with the names of the species we take from our fictional trees.

```{r, eval=FALSE}
mat <- data.frame(rbind(rep(1,8)))

colnames(mat) <- c('A','B','C','D','E','F','G','H')
```

Using that matrix, we will calculate Hill numbers of order 0 to 2 for both trees:

```{r, eval=FALSE}
library(hillR)
tree1_h0 <- hill_phylo(mat,tree1,q=0)
tree1_h1 <- hill_phylo(mat,tree1,q=1)
tree1_h2 <- hill_phylo(mat,tree1,q=2)
tree2_h0 <- hill_phylo(mat,tree2,q=0)
tree2_h1 <- hill_phylo(mat,tree2,q=1)
tree2_h2 <- hill_phylo(mat,tree2,q=2)
```

Let's format this as a dataframe so we can visualize these numbers: the first column will be the order (our X axis), the second column will be the Hill values (our Y axis) and the third column will be the tree it belongs to (which we will use to draw different colored lines for comparison).

```{r, eval=FALSE}
phylo_h <- data.frame(order = c(0,1,2,0,1,2),
                      hill = c(tree1_h0,tree1_h1,tree2_h2,tree2_h0,tree2_h1,tree2_h2),
                      tree = c(rep('tree1',3),rep('tree2',3)))
```

Now we will call `plot` to generate a line plot for the values of the first tree, and then use `lines` to add a line containing the values for the second tree (we used boolean matching subsetting to choose what to plot at each time)

```{r, eval=FALSE}
#Plotting values for tree 1
plot(phylo_h$order[phylo_h$tree=='tree1'],
     phylo_h$hill[phylo_h$tree=='tree1'],
     type='b',col='darkred',
     xlab = 'Order',ylab='Hill values')

# Plotting values for tree 2
lines(phylo_h$order[phylo_h$tree=='tree2'],
     phylo_h$hill[phylo_h$tree=='tree2'],
     type='b',col='red')
```

From this plot, we can notice a few patterns:

1) The hill values for tree 1 are usually higher than those for tree 2, indicating that our community contains a deeper evolutionary history with tree 1 (i.e., lineages containg longer branches);
2) The value of the hill numbers drop as the order goes up. This happens because higher orders are putting less and less emphasis on branch lengths that are not so common (like, for instance, the short branch lenghts in tree 1). In order words, higher order emphasize what is more common.
3) The rate of change of the value as we increase the order is also different among trees. Tree 1 is a more uneven tree; it is composed mostly of somewhat long branches, and few short branches. So, when we change the order, we notice a significant change in the value (at least more significant than the change seen in tree2), because there's a part of the tree we are starting to disconsider (i.e., those short branch lengths that are not so common). We observe a smaller change in tree 2 because all branches have very similar lenghts, so changing the order does not affect the overall diversity (in other words, all branch lenghts are equally common, so emphasize more or less common lenghts does not change much the values).

What would happen if the taxa in our communities had different relative abundances? In this case, not only the relative frequency of a branch length would affect our summary statistic, but also how abundant is the taxon that has each branch length. For instance, in tree 1, even though long branches are over represented, maybe the species with long branches are actually super rare in our community, and the short-branch species are actually super abundant. As you can probably realize, this difference suggests something about the evolutionary history of our community, in this case that the most abundant species have a very recent evolutionary history. Similarly, even though branch lengths are very even in tree 2, if some of the species is more abundant than others, it suggests that the evolutionary history of the tree is unevenly represented in our community.

Conveniently, the `hill_phylo` function will take into account both the relative frequency of branch lenghts *AND* the abundance of extant taxon in the phylogeny we provide. For our simple example, we can see how that changes our results by creating site-by-species matrix where abundance goes up from species A to species H (for simplicity, we'll just use values from 1 to 8).

```{r, eval=FALSE}
mat <- data.frame(rbind(seq(1,8)))
colnames(mat) <- c('A','B','C','D','E','F','G','H')
```

Now, let's calculate the same hill numbers with this new community. We save the values to objects with `_rel` at the end, to highlight in this case the taxa had different *rel*ative abundances.

```{r, eval=FALSE}
tree1_h0_rel <- hill_phylo(mat,tree1,q=0)
tree1_h1_rel <- hill_phylo(mat,tree1,q=1)
tree1_h2_rel <- hill_phylo(mat,tree1,q=2)
tree2_h0_rel <- hill_phylo(mat,tree2,q=0)
tree2_h1_rel <- hill_phylo(mat,tree2,q=1)
tree2_h2_rel <- hill_phylo(mat,tree2,q=2)
```

Then we add the new values to our `phylo_h` dataframe. We will signal they belong to `tree1_rel` and `tree2_rel`, meaning they came from a community with different *rel*ative abundance.

```{r, eval=FALSE}
phylo_h <- rbind(phylo_h,
                 data.frame(order = c(0,1,2,0,1,2),
                            hill = c(tree1_h0_rel,tree1_h1_rel,tree1_h2_rel,
                                     tree2_h0_rel,tree2_h1_rel,tree2_h2_rel),
                            tree = c(rep('tree1_rel',3),rep('tree2_rel',3))))

#Plotting values for tree 1
plot(phylo_h$order[phylo_h$tree=='tree1'],
     phylo_h$hill[phylo_h$tree=='tree1'],
     type='b',col='darkred',
     xlab = 'Order',ylab='Hill values',
     ylim = range(phylo_h$hill))

# Plotting values for tree 2
lines(phylo_h$order[phylo_h$tree=='tree2'],
     phylo_h$hill[phylo_h$tree=='tree2'],
     type='b',col='red')

# Plotting values for tree 2
lines(phylo_h$order[phylo_h$tree=='tree1_rel'],
     phylo_h$hill[phylo_h$tree=='tree1_rel'],
     type='b',col='darkblue')

# Plotting values for tree 2
lines(phylo_h$order[phylo_h$tree=='tree2_rel'],
     phylo_h$hill[phylo_h$tree=='tree2_rel'],
     type='b',col='lightblue')
```

Reminders: 1) red is equal abundance and blue is different abundances; 2) darker colors represent `tree1` (uneven branch length) and lighter colors represent `tree2` (equal branch lengths).

From this second plot, we notice that:

1) Hill number values for tree 1 (darker colors) are still higher than those for tree 2 (lighter colors). This makes sense since the relative abundance is the same for both trees, so the overall pattern (i.e., longer branches in tree 1) remains;

2) the Hill number of order 0 is the same regardless of whether you have different relative abundances among species, since order 0 is simply the sum of all branch lengths (i.e., it does not account for how the relative abundance of taxa);

3) when we include different relative abundance among taxa, we have a higher rate of decrease in the Hill number value as we increase the order. This is because higher orders are now being calculated based on how common/rare each branch is in our community (based on our site-by-species matrix). If we take tree 1, for instance, we see that the Hill value for order 1 including different taxa abundance (darker blue line) is lower than the value where abundance is equal (darker red line). We can interpret this as our metric putting less weight on the longer branches of tree 1, which are rare in our community, and putting more weight on the shorter branches, which are more common but represent a more recent evolutionary history. We see a similar (although less accentuated) pattern with tree2. Calculating different order of hill numbers while incorporating species abundance therefore allows to have a single metric accounting for evolutionary history and species abundance distribution that is comparable across different regions.

:::::::::::::::::: instructor
    
    A question that may arise from the audience is why for order 2 the matrix with different taxa abundance yields higher Hill number value (i.e., it is the reverse of the pattern for order 1). This may give an opportunity to further discuss how Hill numbers are balancing out relative abundance with evolutionary history. I believe order 2 is reflecting that the high abundance of short branch taxa (like G and H) yields higher PD than when we don't have thar relative abundance and are just focusing on the few long branch taxa (like A and B).

:::::::::::::::::::::::::::::::::::::::::::::::::::

::: challenge

Now that you got an intuition on the information phylogenetic Hill numbers can give us, let's move on to our actual data. For this challenge, you should calculate the phylogenetic Hill numbers of orders 0, 1 and 2 for three islands we are working with throughout these episodes. The key objects here will be the `phylogeny` tree we imported earlier, as well as the `phylo_wide` object containing our site-by-species matrix modified to match the tips in our phylogeny. You should also plot the hill numbers for each island and discuss what the calculated values allow you to infer regarding the history of each community.

::: solution

<!-- We gotta simulate the data to finalize this solution section. -->

::::::::::::

::::::::::::


## Graveyard

Because the entire tree of 

```{r rotl ott ids}
library(rotl)

abundances <- read.csv("https://raw.githubusercontent.com/role-model/multidim-biodiv-data/rmd-review/episodes/data/abundances_resolved.csv")

# This is kind of a mixed cleaning/analysis interlude that seems like it belongs below.

resolved_names <-  tnrs_match_names(abundances$final_name)

# Remove names that aren't a perfect match

good_names <- resolved_names[ !resolved_names$approximate_match,]
good_names <- good_names[ !is.na(good_names$approximate_match), ]

# Remove a couple of ott ids that seem to confuse tol_induced_subtree

good_names <- good_names[ good_names$ott_id != "3574707", ]
good_names <- good_names[ good_names$ott_id != "737065", ]
```

Next, we can query the Open Tree of Life for those IDs using the `tol_induced_subtree` function.

```{r tol subtree}

arthro_tree <- tol_induced_subtree(ott_id = (good_names$ott_id))

```

In this section, we will deal with these issues in order to prepare our data for community inferences. Our first issue will be dealt with in a challenge!

### Resolving taxonomic names

::: challenge

In previous episodes, we have used the package `taxize` to clean and standardize the taxonomic names in out dataset. Here, we will apply the same approach to the tip names of our phylogeny. We need to make sure the names we will accept from `taxize` will match the names we have accepted in previous episodes. Finally, after we decide on the names, we need to add them to the `phylogeny` objects, where the tip names are stored.

::: solution

First, we check the names using the `gnr_resolve()` function. In `phylogeny`, tip names are stored in `phylogeny$tip.label`, so we provide that vector to our function.

```{r phylo-resolve-sol1}
library(taxize)
phylogeny <- arthro_tree

phylo_tip_names <- phylogeny$tip.label

for(i in 1:length(phylo_tip_names)) {
    phylo_tip_names[i] <- strsplit(phylo_tip_names[i][1], "_ott")[[1]][1]
     phylo_tip_names[i] <- gsub("_", " ", phylo_tip_names[i])
}


phylo_tip_names

name_resolve <- gnr_resolve(phylo_tip_names, best_match_only = TRUE, canonical = TRUE)
head(name_resolve)
```

We can see what taxa are in conflict with the names retrieved by `taxize` by subsetting `name_resolve` based on boolean matching.

```{r phylo-resolve-sol2}
mismatches_phylo <- name_resolve[name_resolve$user_supplied_name != name_resolve$matched_name2, c("user_supplied_name", "matched_name2")]

mismatches_phylo
```

From here, we can see that apparently there are no misspellings in our tree (as expected from a published phylogeny). Most of the mismatches seem to be related to changes in the taxonomic treatment of species. This is a common situation, since taxonomic treatments are often revised after new trees are published; it might be the case that `nameA` in our dataset was treated as `nameB` at the time the phylogeny was created.

In the previous episodes, we used the names provided by `taxize` directly. Therefore, here we can just add those names directly to the phylogeny.

```{r phylo-resolve-sol3}
phylogeny$tip.label <- name_resolve$matched_name2

```

::::::::::::

::::::::::::

**RMD commenting May 26. With taxize down, and using `rotl` for both name resolution and getting the phylogeny, there aren't going to be mismatched names in the phylogeny.**

**But, there is the potential for missing names...**

**For now, RMD is commenting out the phylo cleaning section. If we end up continuing with `rotl` for both cleaning + phylo, I think there will be an opportunity to do name/broken taxon fixing. Some of this is covered in an R Open Tree of Life Carpentries lesson here: https://mctavishlab.github.io/R_OpenTree_tutorials/03-broken-taxa/index.html (which is what RMD is working from).**


We will use the `setdiff` function to see the differences between the list of names from `abundances` and the one from the phylogeny.

```{r checking-missing-tips}

phylo_names <- arthro_tree$tip.label

unfound_names <- setdiff(all_names, phylo_names)

```

---
Another option, that uses the `%in%` operator and the indexing rationale for sub-setting.

